# 🧠 LeetCode Log – Day 1

## 🔢 Problem: 1768. Merge Strings Alternately

---

### 🧠 Notes

- ❌ Confused C syntax with Python:
  Tried `list[i] = word1[i]` — works in C, not in Python.
  Need to use `.append()` or `.insert()`.

- 🔍 Observation:
  - `word1` characters go to even indices
  - `word2` characters go to odd indices

- 🧪 Initial Strategy:
  - Tried two pointers (`i`, `j`) in nested while loops.
  - Logic was partially working, but skipped characters due to incorrect nesting and pointer updates.
  - Output like `[a, p]` showed up but the full interleaving failed.

- ❗ Mistakes:
  - Did not think in English or pseudocode before coding.
  - Rushed to code without laying out logic.
  - Checked hints too early.
  - Relied on Copilot for fixes instead of building logic myself.

- ✅ Takeaway:
  For string interleaving problems, think in terms of string construction — not list positions.  
  Use a clear approach with boundaries (`min(len1, len2)`) and handle leftovers separately.

---

### ❌ Initial Attempt (Flawed Logic)

**Buggy Code:**

```python
word1 = "abc"
word2 = "pqr"
list1 = list(word1)
list2 = list(word2)
list3 = list()
i = 0
j = 1

for k in range(len(word1) + len(word2)):
    while i < len(word1):
        while j < len(word2):
            list3.append(word1[i])
            list3.append(word2[j - 1])
            j = j + 2
            i = i + 2

print(list3)
###✅ Approach 1 (Using a while loop and list)

-Simple and safe: prevents index out-of-bound by checking index each time.

-Appends characters from word1 and word2 alternatively.

-Time Complexity: O(n + m)

-Space Complexity: O(n + m)
---
```
def mergeAlternately(word1, word2):
    result = []
    i = 0 
    while i < len(word1) or i < len(word2):
        if i < len(word1):
            result.append(word1[i])
        if i < len(word2):
            result.append(word2[i])
        i += 1
    return "".join(result)
```
---
###✅ Final Approach  (Using string concatenation and slicing)

-Cleaner and faster; avoids multiple conditional checks.

-Handles leftover characters elegantly using slicing.

-Execution Time: 42ms

-Memory: 17.47MB (beats 99.5%)

-Time Complexity: O(n + m)

-Space Complexity: O(n + m)
---
```
def mergeAlternately(word1, word2):
    string3 = ""
    count = 0
    while count < min(len(word1), len(word2)):
        string3 += word1[count] + word2[count]
        count += 1
    return string3 + word1[count:] + word2[count:]
```
---
###🧾 Closing Thoughts
“Not a great start, but it’s the journey that counts. Will keep pushing.”

— Sharat Doddihal
