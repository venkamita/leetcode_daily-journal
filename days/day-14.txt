21. Merge Two Sorted Lists
Hello today's problem is as stated above. My approach is a bit unique and is although not efficient as the standard 
two pointer approach I feel this is quite a creative approach. So what I did was dump the values from both the linked lists
straight in a static array then I used the qsort function to sort the array. Then I rebuilt the linked list nodes and connections 
again. 
Code:
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
#include<stdlib.h>
int comp(const void* a, const void* b) {
    return (*(int*)a - *(int*)b);
}

struct ListNode* createnode(int newdata){
    struct ListNode* newnode=malloc(sizeof(struct ListNode));
    newnode->val=newdata;
    newnode->next=NULL;
    return newnode;
 }
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
    int arr[100];
    if(list1==NULL && list2==NULL){
        return list1;
    }
    if(list1==NULL){
        return list2;
    }
    if(list2==NULL){
        return list1;
    }
    struct ListNode* ptr1=list1;
    struct ListNode* ptr2=list2;
    int i=0;
    while(ptr1!=NULL){
        arr[i]=ptr1->val;
        ptr1=ptr1->next;
        i++;
    }
   
    while(ptr2!=NULL){
        arr[i]=ptr2->val;
        ptr2=ptr2->next;
        i++;
    }
    
    qsort(arr,i,sizeof(int),comp);
    struct ListNode* head=createnode(arr[0]);
    struct ListNode* tail=head;

    for(int j=1;j<i;j++){
      tail->next=createnode(arr[j]);
      tail=tail->next;

    }
    return head;


}
Signing off-
Sharat Doddihal